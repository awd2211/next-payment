# 认证架构指南

## 概述

支付平台使用**两层认证模型**:

1. **BFF 层**: Admin BFF 和 Merchant BFF 通过 JWT 处理用户认证
2. **内部服务**: 大多数内部服务不需要认证,因为它们通过 BFF 调用

---

## 认证层级

### 第一层: 面向前端的服务 (需要认证)

这些服务处理来自前端应用的直接请求并实现完整认证:

| 服务 | 端口 | 认证方法 | 授权 |
|------|------|---------|------|
| **admin-bff-service** | 40001 | JWT + 2FA | RBAC (6 个角色) |
| **merchant-bff-service** | 40023 | JWT | 租户隔离 |
| **payment-gateway** | 40003 | JWT + 签名 | 商户 API 密钥 |
| **cashier-service** | 40016 | JWT | 基本认证 |
| **merchant-auth-service** | 40011 | JWT | 自身 (认证服务) |

**认证流程**:
```
前端 → BFF 服务 → JWT 验证 → RBAC 检查 → 内部服务调用
```

### 第二层: 内部服务 (无需认证)

这些服务仅被其他后端服务调用 (特别是通过 BFF),在 HTTP 路由级别不需要认证:

| 服务 | 端口 | 安全模型 | 调用方 |
|------|------|---------|--------|
| accounting-service | 40007 | 受信任网络 | BFF, payment-gateway |
| analytics-service | 40009 | 受信任网络 | BFF, Kafka 消费者 |
| channel-adapter | 40005 | 受信任网络 | payment-gateway |
| config-service | 40010 | 受信任网络 | 所有服务 |
| dispute-service | 40021 | 受信任网络 | BFF |
| kyc-service | 40015 | 受信任网络 | BFF |
| notification-service | 40008 | 受信任网络 | BFF, 所有服务 |
| order-service | 40004 | 受信任网络 | payment-gateway, BFF |
| reconciliation-service | 40020 | 受信任网络 | BFF |
| risk-service | 40006 | 受信任网络 | payment-gateway |
| settlement-service | 40013 | 受信任网络 | BFF |
| withdrawal-service | 40014 | 受信任网络 | BFF, settlement-service |
| merchant-policy-service | 40012 | 受信任网络 | BFF |
| merchant-quota-service | 40022 | 受信任网络 | BFF |

**安全假设**:
- 这些服务部署在私有 VPC 或 Kubernetes 集群中
- 网络策略限制从集群外部访问这些服务
- 服务到服务通信通过私有网络进行
- 可选地可以为生产环境的服务到服务认证添加 mTLS

---

## 问题: 内部服务中未使用的 JWT 管理器

### 当前情况 (高优先级-003)

许多内部服务 (11 个服务) 创建 JWT 管理器实例但从未使用:

```go
// 在 cmd/main.go 中
jwtSecret := config.GetEnv("JWT_SECRET", "your-secret-key")
jwtManager := auth.NewJWTManager(jwtSecret, 24*time.Hour)
_ = jwtManager // 预留给需要认证的路由使用
```

**受影响的服务**:
- accounting-service
- analytics-service
- channel-adapter
- config-service
- dispute-service
- kyc-service
- notification-service
- order-service
- reconciliation-service
- risk-service
- withdrawal-service

### 为什么会这样

**根本原因**: 这些服务在搭建脚手架时考虑了直接前端访问的 JWT 管理器代码,但后来采用了 BFF 模式。

### 影响

1. **内存浪费**: 每个服务约 100KB 用于未使用的 JWT 管理器
2. **代码混淆**: 开发人员可能认为路由受到保护,但实际上没有
3. **虚假安全**: 在没有实际执行的情况下产生认证的印象

### 建议

选择以下方法之一:

#### 选项 A: 删除未使用的 JWT 管理器 (推荐)

**对于永远不会有直接前端访问的内部服务:**

```go
// 删除这些行:
// jwtSecret := config.GetEnv("JWT_SECRET", "your-secret-key")
// jwtManager := auth.NewJWTManager(jwtSecret, 24*time.Hour)
// _ = jwtManager
```

**理由**: 代码简洁,无未使用资源,意图明确

#### 选项 B: 为将来使用记录

**如果将来有可能需要该服务的认证:**

```go
// JWT 认证目前由 BFF 层处理。
// 如果此服务需要直接前端访问,请取消注释以下内容:
// jwtSecret := config.GetEnv("JWT_SECRET", "your-secret-key")
// jwtManager := auth.NewJWTManager(jwtSecret, 24*time.Hour)
```

**理由**: 在不浪费资源的情况下保留能力

#### 选项 C: 应用认证 (不推荐用于内部服务)

**仅当您想添加纵深防御时:**

```go
jwtManager := auth.NewJWTManager(jwtSecret, 24*time.Hour)
authMiddleware := middleware.AuthMiddleware(jwtManager)

// 应用到所有路由
api := router.Group("/api/v1")
api.Use(authMiddleware) // 现在是必需的!
```

**理由**: 纵深防御,但增加延迟和复杂性

---

## 生产安全建议

### 对于 VPC/私有网络部署:
1. ✅ 使用网络策略限制对内部服务的访问
2. ✅ 仅将 BFF 服务暴露到公共互联网
3. ✅ 使用服务网格 (Istio) 在服务之间进行 mTLS
4. ✅ 监控服务到服务的流量

### 对于公有云部署:
1. ✅ 在私有子网中部署内部服务
2. ✅ 为 BFF 服务使用 API 网关
3. ✅ 在内部服务上实施 IP 白名单
4. ✅ 为服务到服务通信添加 mTLS

### 对于 Kubernetes 部署:
1. ✅ 使用 NetworkPolicies 限制 pod 到 pod 的通信
2. ✅ 使用 ServiceAccounts 作为服务身份
3. ✅ 部署服务网格 (Istio/Linkerd) 以实现自动 mTLS
4. ✅ 使用 RBAC 进行集群资源访问

---

## 认证决策树

```
此服务是否由前端直接调用?
├─ 是 → 实现完整的 JWT 认证 + RBAC
│         示例: admin-bff-service, merchant-bff-service
│
└─ 否 → 它在受信任的网络中吗?
    ├─ 是 → 不需要 HTTP 级别的认证 (信任网络策略)
    │         示例: order-service, channel-adapter
    │
    └─ 否 → 添加服务到服务的认证
              方法: mTLS, API 密钥, 带服务帐户的 JWT
```

---

## 迁移路径 (如果需要)

如果您的部署需要内部服务上的认证:

### 步骤 1: 启用 JWT 验证
```go
jwtManager := auth.NewJWTManager(jwtSecret, 24*time.Hour)
authMiddleware := middleware.AuthMiddleware(jwtManager)
api.Use(authMiddleware)
```

### 步骤 2: 更新调用服务
所有调用此内部服务的服务现在必须传递 JWT:
```go
req.Header.Set("Authorization", "Bearer "+token)
```

### 步骤 3: 更新 BFF 服务
BFF 服务必须将其 JWT 传播到内部服务:
```go
// 在 BFF 服务中
internalServiceToken := c.GetHeader("Authorization")
internalReq.Header.Set("Authorization", internalServiceToken)
```

---

## 服务到服务认证 (高级)

对于需要服务到服务认证的生产环境:

### 选项 1: 通过服务网格的 mTLS

**最适合**: Kubernetes 部署

```yaml
# Istio 示例
apiVersion: security.istio.io/v1beta1
kind: PeerAuthentication
metadata:
  name: default
spec:
  mtls:
    mode: STRICT
```

### 选项 2: API 密钥

**最适合**: 简单部署

```go
// 在内部服务中
apiKey := c.GetHeader("X-Internal-API-Key")
if apiKey != config.GetEnv("INTERNAL_API_KEY", "") {
    c.JSON(403, gin.H{"error": "Invalid API key"})
    return
}
```

### 选项 3: 服务帐户 JWT

**最适合**: 复杂微服务

```go
// 每个服务获取自己的 JWT,使用服务帐户签名
serviceToken := auth.GenerateServiceToken(serviceName)
req.Header.Set("X-Service-Token", serviceToken)
```

---

## 认证方法详解

### 1. JWT (JSON Web Token) 认证

**适用场景**: 用户认证、会话管理

**工作原理**:
```go
// 1. 用户登录,服务器生成 JWT
token, err := jwtManager.Generate(userID, claims)

// 2. 前端在后续请求中携带 JWT
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

// 3. 服务器验证 JWT
claims, err := jwtManager.Validate(token)
```

**优点**:
- ✅ 无状态 (服务器不需要存储会话)
- ✅ 可扩展性好 (适合微服务)
- ✅ 支持跨域 (CORS)
- ✅ 包含用户信息 (减少数据库查询)

**缺点**:
- ❌ 无法主动失效 (除非使用黑名单)
- ❌ Token 泄漏风险 (需要短过期时间)
- ❌ Payload 大小限制

**最佳实践**:
- 使用短过期时间 (1-24 小时)
- 实现刷新令牌机制
- 使用 HTTPS 传输
- 不在 JWT 中存储敏感信息

### 2. 签名验证 (Signature Verification)

**适用场景**: API 调用、Webhook、第三方集成

**工作原理**:
```go
// 1. 客户端使用密钥生成签名
timestamp := time.Now().Unix()
signString := fmt.Sprintf("%s%s%d", method, path, timestamp)
signature := hmac.SHA256(signString, apiSecret)

// 2. 请求头携带签名
X-API-Key: merchant_abc123
X-Timestamp: 1698765432
X-Signature: a1b2c3d4e5f6...

// 3. 服务器验证签名
expectedSig := hmac.SHA256(signString, merchantSecret)
if signature != expectedSig {
    return errors.New("invalid signature")
}
```

**优点**:
- ✅ 防重放攻击 (结合时间戳)
- ✅ 防篡改 (任何修改都会导致签名失效)
- ✅ 无需会话存储
- ✅ 适合 API 集成

**缺点**:
- ❌ 需要安全地分发密钥
- ❌ 密钥轮换复杂
- ❌ 时钟同步问题

**最佳实践**:
- 使用 HMAC-SHA256 或更强算法
- 设置签名有效期 (5-10 分钟)
- 实现 nonce 防重放
- 支持多版本密钥 (平滑轮换)

### 3. 2FA/TOTP (双因素认证)

**适用场景**: 高安全操作 (支付、提现、设置修改)

**工作原理**:
```go
// 1. 用户启用 2FA,服务器生成密钥
secret, qrCode := totp.Generate(userEmail)

// 2. 用户扫描 QR 码添加到认证器 App
// 3. 执行敏感操作时要求 TOTP 码
code := c.GetHeader("X-TOTP-Code")
valid := totp.Validate(code, secret)
```

**优点**:
- ✅ 即使密码泄漏也安全
- ✅ 符合 PCI DSS、GDPR 等合规要求
- ✅ 用户体验好 (Google Authenticator 等 App)

**缺点**:
- ❌ 用户设置门槛
- ❌ 手机丢失恢复复杂
- ❌ 时钟同步问题

**最佳实践**:
- 提供备用恢复码
- 允许多个 2FA 设备
- 实现时钟偏移容忍 (±1 时间窗口)
- 仅对敏感操作强制 2FA

### 4. RBAC (基于角色的访问控制)

**适用场景**: 多角色系统 (管理员、操作员、财务等)

**工作原理**:
```go
// 1. 定义角色和权限
roles := map[string][]string{
    "super_admin": {"*"},
    "operator":    {"merchant:read", "merchant:update", "order:read"},
    "finance":     {"accounting:*", "settlement:*"},
}

// 2. 检查权限
func (m *RBACMiddleware) CheckPermission(userRole, resource, action string) bool {
    permissions := roles[userRole]
    required := fmt.Sprintf("%s:%s", resource, action)
    return contains(permissions, required) || contains(permissions, "*")
}
```

**优点**:
- ✅ 权限管理集中
- ✅ 易于审计
- ✅ 符合最小权限原则
- ✅ 灵活的权限组合

**缺点**:
- ❌ 角色爆炸问题 (角色过多)
- ❌ 需要仔细设计权限模型

**最佳实践**:
- 使用通配符简化配置 (`*`, `resource:*`)
- 实现权限继承
- 记录所有权限检查 (审计日志)
- 定期审查角色权限

### 5. 租户隔离 (Tenant Isolation)

**适用场景**: 多租户 SaaS 系统

**工作原理**:
```go
// 1. JWT 中包含租户 ID
claims := Claims{
    UserID:     "user123",
    MerchantID: "merchant_abc", // 租户 ID
}

// 2. 强制注入租户过滤
func (m *TenantMiddleware) InjectTenantID(c *gin.Context) {
    merchantID := c.GetString("merchant_id") // 从 JWT 提取

    // 强制添加到所有数据库查询
    c.Set("tenant_filter", merchantID)
}

// 3. Repository 层自动过滤
func (r *OrderRepository) List(ctx context.Context) ([]Order, error) {
    merchantID := ctx.Value("tenant_filter").(string)
    return r.db.Where("merchant_id = ?", merchantID).Find(&orders).Error
}
```

**优点**:
- ✅ 防止跨租户数据泄漏
- ✅ 自动化 (开发者无需手动过滤)
- ✅ 符合数据隔离要求

**缺点**:
- ❌ 需要在所有查询中添加过滤
- ❌ 性能开销 (额外的 WHERE 条件)

**最佳实践**:
- 在中间件层强制注入
- 使用 ORM hooks 自动过滤
- 定期审计跨租户查询
- 为每个租户设置独立数据库 (最强隔离)

---

## 认证流程图

### Admin Portal 认证流程
```
用户登录
  ↓
Admin BFF 验证用户名密码
  ↓
生成 JWT (包含 user_id, role)
  ↓
返回 JWT 给前端
  ↓
前端存储 JWT (localStorage/sessionStorage)
  ↓
后续请求携带 JWT
  ↓
Admin BFF 验证 JWT → RBAC 检查
  ↓
调用内部服务 (无需认证)
  ↓
返回数据 (脱敏后)
```

### Merchant Portal 认证流程
```
商户登录
  ↓
Merchant BFF 验证用户名密码
  ↓
生成 JWT (包含 user_id, merchant_id)
  ↓
返回 JWT 给前端
  ↓
前端存储 JWT
  ↓
后续请求携带 JWT
  ↓
Merchant BFF 验证 JWT
  ↓
提取 merchant_id (租户隔离)
  ↓
调用内部服务 (强制注入 merchant_id)
  ↓
返回数据 (仅当前租户)
```

### Payment Gateway API 认证流程
```
商户后端调用 API
  ↓
计算签名 (HMAC-SHA256)
  ↓
发送请求 (API Key + Timestamp + Signature)
  ↓
Payment Gateway 验证签名
  ↓
检查 IP 白名单 (可选)
  ↓
检查 API 密钥状态 (是否过期/禁用)
  ↓
调用内部服务 (order, channel, risk)
  ↓
返回结果
```

---

## 总结

**当前架构** (推荐大多数部署):
- ✅ BFF 服务处理认证
- ✅ 内部服务信任网络
- ✅ 网络策略提供隔离

**增强架构** (用于高安全环境):
- ✅ BFF 服务处理认证
- ✅ 所有服务到服务通信的 mTLS
- ✅ 网络策略 + 服务网格
- ✅ 零信任网络

**不推荐**:
- ❌ 代码中存在未使用的 JWT 管理器
- ❌ 不一致的认证模式
- ❌ 某些内部服务有认证但其他没有

---

## 下一步行动

### 立即 (本周):
1. ✅ 记录认证架构 (本文件)
2. ⏳ 决定未使用的 JWT 管理器使用选项 A 或 B
3. ⏳ 使用认证决策树更新 CLAUDE.md

### 短期 (本月):
4. 如果部署到不受信任的网络,添加服务到服务认证
5. 为生产实现通过服务网格的 mTLS
6. 为 Kubernetes 部署添加网络策略

### 长期 (本季度):
7. 定期安全审计
8. 渗透测试
9. 零信任架构实施

---

## 附录: 安全清单

### JWT 安全清单
- [ ] 使用强密钥 (至少 32 字节随机字符串)
- [ ] 设置合理的过期时间 (不超过 24 小时)
- [ ] 实现刷新令牌机制
- [ ] 使用 HTTPS 传输
- [ ] 不在 JWT 中存储密码
- [ ] 验证 `aud` (audience) 声明
- [ ] 验证 `iss` (issuer) 声明
- [ ] 实现令牌吊销机制 (黑名单或 Redis)

### API 签名安全清单
- [ ] 使用 HMAC-SHA256 或更强算法
- [ ] 包含时间戳防重放 (5-10 分钟窗口)
- [ ] 使用 nonce (一次性随机数)
- [ ] 安全存储 API 密钥 (加密)
- [ ] 实现密钥轮换策略
- [ ] 记录所有签名失败 (审计)
- [ ] 实施 IP 白名单 (可选)
- [ ] 设置速率限制

### RBAC 安全清单
- [ ] 遵循最小权限原则
- [ ] 定期审查角色权限
- [ ] 记录所有权限检查
- [ ] 实现权限继承
- [ ] 为敏感操作添加额外验证 (2FA)
- [ ] 实现操作审计日志
- [ ] 测试权限边界
- [ ] 为超级管理员操作添加双人授权

### 租户隔离安全清单
- [ ] 在中间件层强制注入租户 ID
- [ ] 所有数据库查询包含租户过滤
- [ ] 定期审计跨租户查询
- [ ] 实现租户级别的速率限制
- [ ] 测试租户边界
- [ ] 加密租户敏感数据
- [ ] 实现租户数据导出/删除
- [ ] 监控异常的跨租户访问尝试

---

**文档版本**: 1.0
**最后更新**: 2025-10-26
**负责人**: 后端团队
**状态**: 生效中
